**文档类型**：AI / 待办 PRD（状态型）

**基准**：以当前仓库代码为事实源

**原则**：

不追求“处处接口”，只对以下四类建立稳定 seam：

- 外部依赖
- 可翻译语义
- 退化 / 回退
- 已经改过一次的地方

---

## **A. 预备与基线（认知与记录护栏）**

> 说明：本类任务
> 
> 
> **不涉及改代码**
> 

### **A1. 冻结前台行为基线**

**目的**：保证后台重构不改变用户感知

**输出物**：一份「前台行为清单」

**验收标准**：

- 关键交互/展示不变
    - 语言切换
    - 状态展示
    - fallback 行为一致

**当前状态**：❌ 未完成

**事实说明**：

- 代码中存在事实行为，但未形成显式“用户感知清单”文档

---

### **A2. 建立「变更地图 v0」**

**目的**：把高变更点显性化，避免盲改

**输出物**：一张 ≤10 项的变更地图

**验收标准**：

- 每项包含：
    - 变更概率
    - 影响面
    - 当前入口
    - 预期 seam 入口

**当前状态**：❌ 未完成

**事实说明**：

- 尚未形成集中式“高风险改动点”列表

> 变更地图建议优先列这 10 类：
> 

> 翻译 / 语言 fallback / 数据源 / 缓存 / 断流策略 / 阈值与规则表 / statusKey 映射 / 日志与调试开关 / 环境变量与配置入口 / provider 选择逻辑
> 

---

### **A3. 建立「封版日志最小模板」**

**目的**：解决“改了但没记”的失忆问题

**输出物**：3 行最小模板（可贴手机 / commit）

**验收标准**：

- 每次封版至少能记录：
    - 动了哪些模块
    - 是否改中文母本
    - 是否影响语义映射

**当前状态**：✅ 已完成

**事实说明**：

- 佑酱人工在notion里手动做停止日志啦

---

## **B. 外部依赖 Seams（Provider 化）**

> 说明：此处目标是**选择点可收口**
> 

### **B1. 列出所有外部依赖清单**

**目的**：先知道“外面接了谁”

**输出物**：ExternalDeps.md / 表格

**验收标准**：

- 包含：
    - 翻译（DeepL / Worker / 本地）
    - 气象与空间数据（NOAA / ECMWF / JMA 等）
    - 时间 / 地图 / 存储 / Worker

**当前状态**：❌ 未完成

**事实说明**：

- 依赖信息分散在代码与注释中，未形成集中清单

---

### **B2. 为「翻译」建立单点入口（Translate Provider）**

**目的**：为未来切换翻译实现预留入口

**输出物**：translateProvider（概念层）

**验收标准**：

- 前台不改
- 所有翻译请求从单一入口发起

**当前状态**：🟡 部分完成

**事实说明**：

- 已存在统一翻译入口 window.I18N（i18n.js）
- UI / app 层统一通过 i18n.t / th 获取文案
- 但尚未形成“可切换 provider”的概念层

---

### **B3. 为「数据源」建立单点入口（Data Provider）**

**目的**：为后续数据源调整做准备

**输出物**：dataProvider（概念层）

**验收标准**：

- 未来更换数据源只改一处选择逻辑

**当前状态**：❌ 未完成

**事实说明**：

- UI 层存在部分收口（window.Data.fetch*）
- app.js 仍直接请求多处数据源，未完全收口

---

### **B4. 统一外部依赖的配置入口**

**目的**：避免 endpoint / timeout / key 分散

**输出物**：config / settings 单文件

**验收标准**：

- 所有 endpoint / key / timeout / retry 集中可查

**当前状态**：❌ 未完成

**事实说明**：

- 配置项分散在 ui.js / app.js 中

---

## **C. 可翻译语义 Seams（语义源与映射稳定）**

> 说明：本类是 AC 当前
> 
> 
> **完成度最高、风险最低**
> 

### **C1. 明确「语义真相源」（canonical）**

**目的**：防止“中文改了但 UI 没同步”

**输出物**：一条硬规则写入文档

**验收标准**：

- 明确规定：
    - 哪个文件/表是唯一语义真相源
    - UI 不反向修改母本

**当前状态**：🟡 事实已存在，文档缺失

**事实说明**：

- i18n.js 的 resources 已成为事实上的语义真相源
- 但尚未以“硬规则”形式写入文档

---

### **C2. statusKey / 关键术语 与自然语言彻底分离**

**目的**：保证多语言长期稳定

**输出物**：statusKey 列表 / 表

**验收标准**：

- statusKey 永不翻译
- 只映射展示文本

**当前状态**：✅ 已完成

**事实说明**：

- model.js 输出 statusKey
- app.js 仅将其作为翻译 key
- i18n.js 提供 STATUS_C* 映射

---

### **C3. 建立「语义变更门禁」**

**目的**：避免顺手改中文却无记录

**输出物**：轻量检查流程

**验收标准**：

- 任意中文母本改动必须留下痕迹
    - 日志 / commit message 关键词

**当前状态**：❌ 未完成

**事实说明**：

- 尚未建立流程或约定

---

### **C4. 建立「对齐检查清单 / 审计」**

**目的**：让差异可见、可审计

**输出物**：对齐清单（md / 表）

**验收标准**：

- 能快速看出：
    - 母本中文 vs UI key
    - 翻译映射缺失项

**当前状态**：🟡 部分完成

**事实说明**：

- 已存在 AUDIT_R4-2b_key_coverage.md
- 当前覆盖模型 key，对全 UI 覆盖不足

---

## **D. 退化与回退 Seams（断流、缓存、拒绝输出）**

> 说明：
> 
> 
> **代码行为已部分存在，但规则未显性化**
> 

### **D1. 写清楚「退化层级」**

**目的**：断流时系统表现一致

**输出物**：DegradePolicy.md

**验收标准**：

- 明确：
    - A 断流 → 用 B
    - B 断流 → 英文
    - 再断流 → 隐藏 / 提示 / 拒绝判断

**当前状态**：🟡 代码存在，文档缺失

**事实说明**：

- app.js / ui.js 中已有多级回退逻辑
- 未形成统一说明文档

---

### **D2. 统一「超时 / 重试 / 降级」策略入口**

**目的**：避免各 fetch 各写各的

**输出物**：requestPolicy（概念层）

**验收标准**：

- timeout / retry / backoff / fallback 策略集中

**当前状态**：❌ 未完成

**事实说明**：

- fetch 策略分散在多处函数中

---

### **D3. 缓存策略收口**

**目的**：在更新数据源前先定规则

**输出物**：缓存规则说明

**验收标准**：

- 明确：
    - 缓存键
    - TTL
    - 失效条件
    - 断流是否可用旧数据

**当前状态**：🟡 代码存在，规则未显性

**事实说明**：

- 已使用 localStorage / LKG cache
- 但未形成集中说明

---

## **E. 重构执行顺序（参考用）**

> 说明：此顺序为
> 
> 
> **建议流程**
> 

当前事实状态概览：

- **已完成**：C2 / A3
- **事实存在但需补文档**：C1 / D1 / D3
- **部分完成**：B2 / C4
- **尚未开始**：A1 / A2、B1/B3/B4、C3、D2

---

# **⬇️ 数据源调试 · 热插拔最低保障项**

对照 [⚠️ 数据源全面审计](https://www.notion.so/2ee1067b3e2c809d8d5dd69f9fe39183?pvs=21)

### **✅ 前置项 1：B3 · 数据源单点入口（必须先做）**

**PRD 对应**：B3 Data Provider

**为什么它是第一优先级**：

你的《数据源全面审计》要求你对每个字段回答：

> 这是哪来的？实时 / 预报 / 分析？什么时候？缓存了吗？
> 

👉 **如果 fetch 分散在 app.js / ui.js 各处，你根本没法回答这个问题。**

### **最低完成标准（注意：不是完整 Provider）**

你现在**不需要**：

- 抽象接口
- 多实现
- 工厂模式

你只需要做到这一点（就够）：

> “所有线上数据拉取，都必须经过一个文件 / 一个对象”
> 

例如（示意，不是让你现在写）：

```
DataProvider.getSolarWind()
DataProvider.getClouds()
```

哪怕里面现在只是包一层原来的 fetch，**都算完成**。

👉 这样你做数据源审计时，只改这里，不会污染全局。

---

### **✅ 前置项 2：D2 · 请求 / 超时 / 重试策略收口（非常容易被忽视，但致命）**

**PRD 对应**：D2 requestPolicy

**为什么它必须在数据审计前完成**：

你的数据源审计里反复在问：

- “这是不是实时？”
- “是不是延迟了？”
- “是不是每次点都重新拉？”

但有一个前提问题是：

> “你是不是根本没等到它回来？”
> 

如果现在存在：

- A 接口 timeout = 3s
- B 接口 timeout = 10s
- C 接口没 timeout

那你在审计时看到的“数据缺失 / old / fallback”，**可能全是请求策略假象**。

### **最低完成标准**

同样，不需要复杂设计，只需要：

- 一个地方定义：
    - timeout
    - retry 次数
    - 是否允许 fallback
- 所有 DataProvider 内部 fetch 都用它

👉 这样你在数据审计阶段，**可以确信：问题来自数据，而不是请求行为**。

---

### **✅ 前置项 3：A1 · 前台行为基线（不是文档洁癖，是止损）**

**PRD 对应**：A1 冻结前台行为基线

**为什么它是数据审计的护城河**：

你在审计数据源时，一定会经历这种时刻：

> “欸？怎么现在结果不一样了？”
> 

如果你**没有一份前台行为基线**，你根本分不清：

- 是数据源更准了
- 还是你不小心改了：
    - fallback 顺序
    - 缓存是否命中
    - UI 使用的是新值还是旧值

### **最低完成标准（重点）**

这一步**完全不需要写很多**，只需要一页：

- 列出 5–10 条你现在**承诺不动的用户感知**
    - 同样地点、短时间内，结果是否允许变
    - 数据不可用时，是英文 / 隐藏 / 提示
    - 是否允许“部分字段新、部分字段旧”

👉 它的作用只有一个：

**当你审计数据时，一旦 UI 行为变了，你能立刻知道：这是越界，不是数据结论。**
